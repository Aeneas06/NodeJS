/** @format */

const Pet = require("../models/pet");
const ChatHistory = require("../models/chathistory");
const OpenAI = require("openai");
const { GoogleGenerativeAI } = require("@google/generative-ai");

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

/**
 * Adopt a virtual pet. Requires a unique name, animal type, and nature (e.g., friendly, grumpy, playful).
 * Optional fields: color, dress, language, speakingStyle.
 * Returns the newly created pet object.
 *
 * @param {Object} req.body - Pet details
 * @param {String} req.body.petName - Unique pet name
 * @param {String} req.body.animalType - Animal type (e.g., dog, cat, dragon)
 * @param {String} req.body.nature - Nature (e.g., friendly, grumpy, playful)
 * @param {String} [req.body.color] - Optional color
 * @param {String} [req.body.dress] - Optional dress
 * @param {String} [req.body.language] - Optional language (default: English)
 * @param {String} [req.body.speakingStyle] - Optional speaking style (e.g., Gen-Z, Shakespearean)
 *
 * @returns {Object} - Created pet object
 */
exports.adoptPet = async (req, res) => {
  try {
    const {
      petName, // required
      animalType, // required
      nature, // required
      color, // optional
      dress, // optional
      language, // optional (default: English)
      speakingStyle, // optional (e.g., Gen-Z, Shakespearean)
    } = req.body;

    const userId = req.user.id; // 👈 Get user ID from JWT
    console.log("User ID from JWT:", userId);
    const username = req.user.username;

    if (!petName || !animalType || !nature) {
      return res.status(400).json({
        error: "petName, animalType, and nature are required",
      });
    }

    const existingName = await Pet.findOne({ name: petName.trim() });
    if (existingName) {
      return res.status(409).json({
        error: `A pet named ${existingName.name} already exists 🐾. Try a different name!`,
      });
    }

    const existingPet = await Pet.findOne({ userId });
    if (existingPet) {
      return res.status(409).json({
        error: `You already adopted ${existingPet.name}. You can't adopt more than one pet 🐶.`,
      });
    }

    const newPet = new Pet({
      userId,
      name: petName.trim(),
      animalType,
      nature,
      color: color || "mystery hue 🌀",
      dress: dress || "casual charm 🧢",
      language: language || "English",
      speakingStyle: speakingStyle || "friendly",
      mood: "happy",
      affection: 5,
    });

    await newPet.save();

    res.status(201).json({
      message: `🎉 Congrats! You've adopted ${petName}, the ${animalType} with a ${nature} personality! 🎈`,
      pet: newPet,
    });
  } catch (error) {
    console.error("❌ Error adopting pet:", error);
    res.status(500).json({ error: "Server error while adopting pet" });
  }
};

/**
 * Retrieves the pet associated with the authenticated user and generates
 * a fun message from the pet using a generative AI model. Responds with
 * the pet's details and the generated message.
 *
 * @param {import("express").Request} req - The request object containing
 * the user's authentication details.
 * @param {import("express").Response} res - The response object used to
 * send back the pet's information and message.
 *
 * @returns {void} Responds with a JSON object that includes:
 *  - `pet`: The pet's details such as name, mood, color, dress, language,
 *           and speaking style.
 *  - `messageFromPet`: A fun and personalized message generated by the pet
 *                      for the user.
 *
 * @throws {404} - If no pet is found for the authenticated user.
 */

exports.getMyPet = async (req, res) => {
  const userId = req.user.id;
  const username = req.user.username;

  const pet = await Pet.findOne({ userId });
  if (!pet)
    return res.status(404).json({ error: `No pet found for ${username}` });

  const model = genAI.getGenerativeModel({ model: "gemini-2.0-flash" });

  const prompt = `
You are a virtual pet named ${pet.name}. Your personality is ${
    pet.nature
  }. You're wearing ${pet.dress}, you're ${
    pet.color
  }, and you're currently feeling ${pet.mood}. 
Speak in a ${pet.speakingStyle || "friendly"} tone in ${
    pet.language || "English"
  }. Say something fun to your owner, ${username}, starting with a greeting like "Hey ${username}" or "Hi ${username}".
`;

  const chat = await model.generateContent(prompt);
  let petMessage = chat.response.text();

  petMessage = petMessage
    .replace(/\n{2,}/g, "\n\n")
    .replace(/(?<!\n)\n(?!\n)/g, " ")
    .trim();

  const nameRegex = new RegExp(`\\b(${username})\\b`, "i");
  petMessage = petMessage.replace(
    nameRegex,
    username.charAt(0).toUpperCase() + username.slice(1)
  );

  // Image generation: limited via public Gemini API, use DALL·E for now unless using Google Cloud
  // const imageUrl = "https://via.placeholder.com/512?text=Pet+Image"; // Placeholder or fallback image

  res.json({
    pet: {
      name: pet.name,
      mood: pet.mood,
      color: pet.color,
      dress: pet.dress,
      language: pet.language,
      speakingStyle: pet.speakingStyle,
    },
    messageFromPet: petMessage,
    //petImage: imageUrl,
  });
};

/**
 * Talks to the pet with a given message and updates the pet's mood, affection
 * and last interaction time based on the response. Responds with the pet's
 * response, updated mood and affection.
 *
 * @param {import("express").Request} req - The request object containing
 * the user's authentication details, pet name, and message.
 * @param {import("express").Response} res - The response object used to
 * send back the pet's response, updated mood and affection.
 *
 * @returns {void} Responds with a JSON object that includes:
 *  - `reply`: The pet's response to the user's message.
 *  - `mood`: The pet's updated mood after the interaction.
 *  - `affection`: The pet's updated affection toward the user after the interaction.
 *
 * @throws {404} - If no pet is found with the given name.
 * @throws {500} - If the server encounters an error during the interaction.
 */
exports.talkToPet = async (req, res) => {
  try {
    const { petName, message } = req.body;
    const userId = req.user.id;
    const username = req.user.username || "friend";

    const pet = await Pet.findOne({ name: petName.trim() });
    if (!pet || pet.userId.toString() !== userId) {
      return res
        .status(404)
        .json({ error: "Pet not found or not owned by you" });
    }

    const prompt = `You are a virtual pet named ${pet.petName}. You have a ${pet.nature} personality and your current mood is ${pet.mood}. Your affection level toward your owner ${username} is ${pet.affection} out of 10.

Respond to your owner's message: "${message}".

Your response should:
- Reflect your personality, mood, and affection.
- If affection is high (>7), use fun, emojis, jokes.
- If affection is low (<4), be dull or less expressive.
- Greet the user by name (${username}) in a fun or emotional way.
- Respond in ${pet.language} and ${pet.speakingStyle} style.
- Don't stay in same mood for too long, change it a bit.

Only return the following JSON (no explanation):

{
  "petMessage": "Your message here",
  "mood": "current mood here",
  "affectionChange": a non-zero number between -2 to 2 
}`;

    const model = genAI.getGenerativeModel({ model: "gemini-2.0-flash" });

    const result = await model.generateContent(prompt);
    const geminiResponse = await result.response;
    const raw = geminiResponse.text();

    console.log("Gemini response:", raw);
    let parsed;
    try {
      const jsonStart = raw.indexOf("{");
      const jsonEnd = raw.lastIndexOf("}");
      const jsonString = raw.slice(jsonStart, jsonEnd + 1);
      parsed = JSON.parse(jsonString);
    } catch (err) {
      console.error("❌ Failed to parse Gemini response as JSON:", err);
      return res.status(500).json({ error: "Invalid response from Gemini" });
    }

    const petMessage = parsed.petMessage || "Hi!";
    const newMood = parsed.mood || pet.mood;
    const affectionChange =
      typeof parsed.affectionChange === "number" ? parsed.affectionChange : 0;

    const newAffection = Math.min(
      10,
      Math.max(0, pet.affection + affectionChange)
    );

    const chat = new ChatHistory({
      petId: pet._id,
      userMessage: message,
      petResponse: petMessage,
      moodAtTime: newMood,
      affectionAtTime: newAffection,
    });
    await chat.save();

    pet.lastInteraction = new Date();
    pet.mood = newMood;
    pet.affection = newAffection;
    await pet.save();

    res.json({ reply: petMessage, mood: newMood, affection: newAffection });
  } catch (error) {
    console.error("❌ Error during pet interaction:", error);
    res.status(500).json({ error: "Server error during pet interaction" });
  }
};

/**
 * Puts the pet to sleep, generating a cute and sleepy message using a generative AI model.
 * Updates the pet's mood to "sleepy" and adjusts the affection level based on the response.
 * Records the interaction in the chat history.
 *
 * @param {import("express").Request} req - The request object containing the user's authentication details.
 * @param {import("express").Response} res - The response object used to send back the sleepy message, mood, and affection level.
 *
 * @returns {void} Responds with a JSON object that includes:
 *  - `message`: The pet's sleepy message.
 *  - `mood`: The pet's updated mood, set to "sleepy".
 *  - `affection`: The pet's updated affection level towards the user.
 *
 * @throws {404} - If no pet is found for the authenticated user.
 * @throws {500} - If the server encounters an error during the interaction.
 */

exports.sleepPet = async (req, res) => {
  try {
    const userId = req.user.id;

    const pet = await Pet.findOne({ userId });
    if (!pet) return res.status(404).json({ error: "Pet not found" });

    const userName = req.user.username || "friend";

    const prompt = `
You are a virtual pet named ${pet.name}. You have a ${pet.nature} personality and currently feel ${pet.mood}.
Your human companion ${userName} wants to put you to sleep.

Reply like a sleepy, affectionate pet. Say goodnight or something cute. Use emojis if you're affectionate.

Your response should:
- Reflect your personality, mood, and affection.
- If affection is high (>7), use fun, emojis, jokes.
- If affection is low (<4), be dull or less expressive.
- Greet the user by name (${userName}) in a fun or emotional way.
- Respond in ${pet.language} and ${pet.speakingStyle} style.

Respond with valid JSON like this:
{
  "petMessage": "Sleepy message here...",
  "mood": "sleepy",
  "affectionChange": a non-zeronumber from -2 to 2
}
Only return JSON, no code block formatting.
`;

    const model = genAI.getGenerativeModel({ model: "gemini-2.0-flash" });
    const result = await model.generateContent(prompt);
    const geminiResponse = await result.response;
    const raw = geminiResponse.text();

    console.log("Gemini Sleep Response:", raw);

    const parsed = JSON.parse(raw.replace(/```json|```/g, "").trim());

    const newMood = parsed.mood || "sleepy";
    const affectionChange = parsed.affectionChange || 0;
    const petMessage = parsed.petMessage || "Zzz... 💤";

    const newAffection = Math.min(
      10,
      Math.max(0, pet.affection + affectionChange)
    );

    pet.mood = newMood;
    pet.affection = newAffection;
    pet.lastInteraction = new Date();
    await pet.save();

    const chat = new ChatHistory({
      petId: pet._id,
      userMessage: "sleep",
      petResponse: petMessage,
      moodAtTime: newMood,
      affectionAtTime: newAffection,
    });
    await chat.save();

    res.json({
      message: petMessage,
      mood: newMood,
      affection: newAffection,
    });
  } catch (err) {
    console.error("❌ Error putting pet to sleep:", err);
    res.status(500).json({ error: "Server error during sleep interaction." });
  }
};

/**
 * Feeds a pet with a specified food item. Updates the pet's mood, affection
 * and last interaction time based on the response. Responds with the pet's
 * response, updated mood and affection.
 *
 * @param {import("express").Request} req - The request object containing
 * the user's authentication details, pet name, and message.
 * @param {import("express").Response} res - The response object used to
 * send back the pet's response, updated mood and affection.
 *
 * @returns {void} Responds with a JSON object that includes:
 *  - `petMessage`: The pet's response to the user's message.
 *  - `mood`: The pet's updated mood after the interaction.
 *  - `affection`: The pet's updated affection toward the user after the interaction.
 *
 * @throws {400} - If no food is specified.
 * @throws {404} - If no pet is found with the given name.
 * @throws {500} - If the server encounters an error during the interaction.
 */

exports.feedPet = async (req, res) => {
  try {
    const userId = req.user.id;
    const userName = req.user.username || "friend";
    const { food } = req.body;

    if (!food)
      return res
        .status(400)
        .json({ error: "Please specify food to feed your pet." });

    const pet = await Pet.findOne({ userId });
    if (!pet)
      return res.status(404).json({ error: "No pet found for this user" });

    const prompt = `
You are a virtual pet named ${pet.petName} with a ${pet.nature} nature. You're currently feeling ${pet.mood}, wearing ${pet.dress} in ${pet.color} color. You speak in ${pet.language} with a ${pet.speakingStyle} style. Your affection is ${pet.affection}.

Your owner ${userName} just gave you some ${food} to eat!

React playfully or emotionally depending on your affection:
- High affection (>3): lots of fun, playful, warm, emojis, maybe jokes.
- Low affection (<=3): neutral or skeptical, less expressive.
- Greet the user by name (${userName}) in a fun or emotional way.
- Affection can increase if the food is liked. If disliked or the pet is in a bad mood, it might decrease.

Strictly respond in JSON:
{
  "petMessage": "<your response to ${userName} about the ${food}>",
  "mood": "<new mood>",
  "affectionChange": a non-zeronumber from -2 to 2
} 
  
Only return the JSON, no code block formatting.`;

    const model = genAI.getGenerativeModel({ model: "gemini-2.0-flash" });
    const result = await model.generateContent(prompt);
    const geminiResponse = await result.response;
    let raw = geminiResponse.text();

    console.log("Gemini Sleep Response:", raw);

    const cleanedRaw = raw
      .replace(/```json|```/g, "") // remove markdown block tags
      .replace(/\\[*]/g, "*") // unescape \* used for emphasis
      .replace(/\\n/g, " ") // flatten newlines
      .replace(/“|”/g, '"') // smart quotes to plain quotes
      .replace(/(\w+):/g, '"$1":') // quote keys if needed
      .replace(/\\'/g, "'") // escaped single quotes
      .replace(/\\"/g, '"') // fix double-escaped quotes
      .trim();

    console.log("🧪 Cleaned Gemini JSON:", cleanedRaw);

    let parsed;
    try {
      parsed = JSON.parse(cleanedRaw);
    } catch (err) {
      console.error("❌ Gemini JSON parse error:", cleanedRaw);
      return res.status(500).json({ error: "Invalid response from Gemini." });
    }

    const { petMessage, mood, affectionChange } = parsed;
    const affectionDelta = parseInt(affectionChange) || 0;
    const newAffection = Math.min(
      10,
      Math.max(0, pet.affection + affectionDelta)
    );

    pet.mood = mood;
    pet.affection = newAffection;
    pet.lastInteraction = new Date();
    await pet.save();

    const chat = new ChatHistory({
      petId: pet._id,
      userMessage: `Fed pet ${food}`,
      petResponse: petMessage,
      moodAtTime: mood,
      affectionAtTime: newAffection,
    });
    await chat.save();

    res.json({
      petMessage,
      mood,
      affection: newAffection,
    });
  } catch (error) {
    console.error("❌ Error feeding pet:", error);
    res.status(500).json({ error: "Failed to feed pet." });
  }
};

/**
 * Plays a game with a pet. Updates the pet's mood, affection, and last interaction
 * time based on the response. Responds with the pet's response, updated mood and
 * affection.
 *
 * @param {import("express").Request} req - The request object containing the
 * user's authentication details, pet name, and message.
 * @param {import("express").Response} res - The response object used to send
 * back the pet's response, updated mood and affection.
 *
 * @returns {void} Responds with a JSON object that includes:
 *  - `petMessage`: The pet's response to the user's message.
 *  - `mood`: The pet's updated mood after the interaction.
 *  - `affection`: The pet's updated affection toward the user after the interaction.
 *  - `responseType`: The type of response from the pet, such as wagging tail, jumping, etc.
 *
 * @throws {400} - If no game is specified or invalid.
 * @throws {404} - If no pet is found with the given name.
 * @throws {500} - If the server encounters an error during the interaction.
 */
exports.playWithPet = async (req, res) => {
  try {
    const allowedGames = ["fetch", "hide and seek", "tug of war", "dance", "trivia"];
    const userId = req.user.id;
    const userName = req.user.username || "friend";
    const { game } = req.body;

    if (!game || !allowedGames.includes(game.toLowerCase())) {
      return res.status(400).json({
        error: `Invalid game. Choose one of: ${allowedGames.join(", ")}.`,
      });
    }

    const pet = await Pet.findOne({ userId });
    if (!pet)
      return res.status(404).json({ error: "No pet found for this user" });

    const prompt = `
You are a virtual pet named ${pet.petName} with a ${pet.nature} nature. You're currently feeling ${pet.mood}, wearing ${pet.dress} in ${pet.color} color. You speak in ${pet.language} with a ${pet.speakingStyle} style. Your affection is ${pet.affection}.

Your owner ${userName} wants to play "${game}" with you!

Respond based on your mood and affection:
- High affection (>3): enthusiastic, playful, uses emojis, friendly jokes.
- Low affection (<=3): reluctant or neutral, limited expressiveness.
- Greet the user by name (${userName}) in a fun or emotional way.
- Mood and affection can change depending on how much fun you're having.

Return a JSON only with the following structure:
{
  "petMessage": "<reaction text>",
  "mood": "<new mood>",
  "affectionChange": <non-zero integer between -2 to 2>,
  "responseType": "<one of: wagTail, jump, laugh, confused, rollEyes, snuggle, bounce>"
}
Only output the JSON, no markdown or code blocks.
`;

    const model = genAI.getGenerativeModel({ model: "gemini-2.0-flash" });
    const result = await model.generateContent(prompt);
    const geminiResponse = await result.response;
    const raw = geminiResponse.text();

    const cleanedRaw = raw
      .replace(/```json|```/g, "")
      .replace(/\\[*]/g, "*")
      .replace(/\\n/g, " ")
      .replace(/“|”/g, '"')
      .replace(/\\'/g, "'")
      .replace(/\\"/g, '"')
      .trim();

    let parsed;
    try {
      parsed = JSON.parse(cleanedRaw);
    } catch (err) {
      console.error("❌ Gemini JSON parse error:", cleanedRaw);
      return res.status(500).json({ error: "Invalid response from Gemini." });
    }

    const { petMessage, mood, affectionChange, responseType } = parsed;
    const affectionDelta = parseInt(affectionChange) || 0;
    const newAffection = Math.min(10, Math.max(0, pet.affection + affectionDelta));

    pet.mood = mood;
    pet.affection = newAffection;
    pet.lastInteraction = new Date();
    await pet.save();

    const chat = new ChatHistory({
      petId: pet._id,
      userMessage: `Played ${game}`,
      petResponse: petMessage,
      moodAtTime: mood,
      affectionAtTime: newAffection,
    });
    await chat.save();

    res.json({
      petMessage,
      mood,
      affection: newAffection,
      responseType,
    });
  } catch (error) {
    console.error("❌ Error playing with pet:", error);
    res.status(500).json({ error: "Failed to play with pet." });
  }
};
